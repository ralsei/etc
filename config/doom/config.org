+TITLE:   Hazel's DOOM Emacs configuration
#+AUTHOR:  Hazel Levine
#+EMAIL:   rose.hazel@protonmail.ch
#+STARTUP: nofold

Whee, literate programming, whoo. I get to type words here. These are words on a
screen. Typing. With /haaaaaaands/.

In this file, we tangle the following:
#+BEGIN_SRC emacs-lisp
;;; config.el -*- lexical-binding: t -*-
#+END_SRC
#+BEGIN_SRC emacs-lisp :tangle ~/.config/doom/packages.el
;;; packages.el -*- lexical-binding: t -*-
#+END_SRC

Any calls to =package!= generally get tangled to =packages.el=, whereas
everything else goes to =config.el=.

* Introduction
** =whoami=
I'm a bunny.
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Hazel Levine"
      user-mail-address "hazel@knightsofthelambdacalcul.us")
#+END_SRC
* UI
** Fonts
I've had font rendering issues with Emacs for /years/, ever since I picked it
up. Namely, Emacs' font always looked just different enough from that of
whatever terminal emulator I'm using to be annoying. Thankfully, [[https://github.com/rocx/.emacs.d][rocx's emacs
config]] held the solution by forcing Emacs to use XFT.

I first define a function to create an XFT font string from whatever font, size,
and options I want:
#+BEGIN_SRC emacs-lisp
(defun hzl/xft-font-string (name size &optional properties)
  ;; https://keithp.com/~keithp/render/Xft.tutorial
  (concat (format "%s-%d" name size)
          (when properties
            (apply #'concat (mapcar (lambda (prop)
                                      (format ":%s=%s" (car prop) (cdr prop)))
                                    properties)))))
#+END_SRC

As my university education dragged on and I began to do things with formal logic,
I needed a font with good support for unicode characters. Right now that's [[https://github.com/cormullion/juliamono][Julia
Mono]]. I use the [[https://www.ibm.com/plex/][IBM Plex]] fonts for variable pitch. I used to use IBM Plex Mono,
but it doesn't format some things properly...

I've also disabled bold fonts because I cannot get them to render properly in
Emacs.
#+BEGIN_SRC emacs-lisp
(defvar hzl/monospace-font
  (hzl/xft-font-string "Julia Mono" 10
                       '((hintstyle . 3)
                         (hinting . true)
                         (lcdfilter . 3)
                         (antialias . true))))
(defvar hzl/variable-pitch-font
  (hzl/xft-font-string "IBM Plex Sans" 10
                       '((hintstyle . 3)
                         (autohint . true)
                         (lcdfilter . 3)
                         (antialias . true))))

(setq doom-font hzl/monospace-font)
(setq doom-variable-pitch-font hzl/variable-pitch-font)
(setq doom-unicode-font hzl/monospace-font)
(setq doom-themes-enable-bold nil)
#+END_SRC
** Colorscheme
I've been using [[https://github.com/morhetz/gruvbox][Gruvbox]] Light recently. After years and years of dark themes, I
came to the realization that:
+ Anti-aliasing algorithms were better with black text on a white background
+ I can read light themes without glasses
+ "Burning your eyes" is not a thing that actually happens
#+BEGIN_SRC emacs-lisp
(setq doom-theme 'leuven)
#+END_SRC
** Everything else
Enable line numbers, because those are nice, and make 'em relative:
#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type 'relative)
#+END_SRC

Copy Tecosaur's splash screen because I'm lazy:
#+BEGIN_SRC emacs-lisp
(defvar fancy-splash-image-template
  (expand-file-name "splash/emacs-e-template.svg" doom-private-dir)
  "Default template svg used for the splash image, with substitutions from ")

(defvar fancy-splash-sizes
  `((:height 300 :min-height 50 :padding (0 . 2))
    (:height 250 :min-height 42 :padding (2 . 4))
    (:height 200 :min-height 35 :padding (3 . 3))
    (:height 150 :min-height 28 :padding (3 . 3))
    (:height 100 :min-height 20 :padding (2 . 2))
    (:height 75  :min-height 15 :padding (2 . 1))
    (:height 50  :min-height 10 :padding (1 . 0))
    (:height 1   :min-height 0  :padding (0 . 0)))
  "list of plists with the following properties
  :height the height of the image
  :min-height minimum `frame-height' for image
  :padding `+doom-dashboard-banner-padding' (top . bottom) to apply
  :template non-default template file
  :file file to use instead of template")

(defvar fancy-splash-template-colours
  '(("$colour1" . "#335ea8"))
  "list of colour-replacement alists of the form (\"$placeholder\" . 'theme-colour) which applied the template")

(unless (file-exists-p (expand-file-name "theme-splashes" doom-cache-dir))
  (make-directory (expand-file-name "theme-splashes" doom-cache-dir) t))

(defun fancy-splash-filename (theme-name height)
  (expand-file-name (concat (file-name-as-directory "theme-splashes")
                            theme-name
                            "-" (number-to-string height) ".svg")
                    doom-cache-dir))

(defun fancy-splash-clear-cache ()
  "Delete all cached fancy splash images"
  (interactive)
  (delete-directory (expand-file-name "theme-splashes" doom-cache-dir) t)
  (message "Cache cleared!"))

(defun fancy-splash-generate-image (template height)
  "Read TEMPLATE and create an image if HEIGHT with colour substitutions as
   described by `fancy-splash-template-colours' for the current theme"
  (with-temp-buffer
    (insert-file-contents template)
    (re-search-forward "$height" nil t)
    (replace-match (number-to-string height) nil nil)
    (dolist (substitution fancy-splash-template-colours)
      (goto-char (point-min))
      (while (re-search-forward (car substitution) nil t)
        (replace-match (cdr substitution) nil nil)))
    (write-region nil nil
                  (fancy-splash-filename (symbol-name doom-theme) height) nil nil)))

(defun fancy-splash-generate-images ()
  "Perform `fancy-splash-generate-image' in bulk"
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (fancy-splash-generate-image (or (plist-get size :template)
                                       fancy-splash-image-template)
                                   (plist-get size :height)))))

(defun ensure-theme-splash-images-exist (&optional height)
  (unless (file-exists-p (fancy-splash-filename
                          (symbol-name doom-theme)
                          (or height
                              (plist-get (car fancy-splash-sizes) :height))))
    (fancy-splash-generate-images)))

(defun get-appropriate-splash ()
  (let ((height (frame-height)))
    (cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
             fancy-splash-sizes)))

(setq fancy-splash-last-size nil)
(setq fancy-splash-last-theme nil)
(defun set-appropriate-splash (&rest _)
  (let ((appropriate-image (get-appropriate-splash)))
    (unless (and (equal appropriate-image fancy-splash-last-size)
                 (equal doom-theme fancy-splash-last-theme)))
    (unless (plist-get appropriate-image :file)
      (ensure-theme-splash-images-exist (plist-get appropriate-image :height)))
    (setq fancy-splash-image
          (or (plist-get appropriate-image :file)
              (fancy-splash-filename (symbol-name doom-theme) (plist-get appropriate-image :height))))
    (setq +doom-dashboard-banner-padding (plist-get appropriate-image :padding))
    (setq fancy-splash-last-size appropriate-image)
    (setq fancy-splash-last-theme doom-theme)
    (+doom-dashboard-reload)))

(add-hook 'window-size-change-functions #'set-appropriate-splash)
(add-hook 'doom-load-theme-hook #'set-appropriate-splash)
#+END_SRC

Also copy quotes, because I'm just a complete damned ripoff:
#+BEGIN_SRC emacs-lisp
(defvar phrase-api-url
  (nth (random 3)
       '(("https://corporatebs-generator.sameerkumar.website/" :phrase)
         ("https://useless-facts.sameerkumar.website/api" :data)
         ("https://dev-excuses-api.herokuapp.com/" :text))))

(defmacro phrase-generate-callback (token &optional format-fn ignore-read-only callback buffer-name)
  `(lambda (status)
     (unless (plist-get status :error)
       (goto-char url-http-end-of-headers)
       (let ((phrase (plist-get (json-parse-buffer :object-type 'plist) (cadr phrase-api-url)))
             (inhibit-read-only ,(when (eval ignore-read-only) t)))
         (setq phrase-last (cons phrase (float-time)))
         (with-current-buffer ,(or (eval buffer-name) (buffer-name (current-buffer)))
           (save-excursion
             (goto-char (point-min))
             (when (search-forward ,token nil t)
               (with-silent-modifications
                 (replace-match "")
                 (insert ,(if format-fn format-fn 'phrase)))))
           ,callback)))))

(defvar phrase-last nil)
(defvar phrase-timeout 5)

(defmacro phrase-insert-async (&optional format-fn token ignore-read-only callback buffer-name)
  `(let ((inhibit-message t))
     (if (and phrase-last
              (> phrase-timeout (- (float-time) (cdr phrase-last))))
         (let ((phrase (car phrase-last)))
           ,(if format-fn format-fn 'phrase))
       (url-retrieve (car phrase-api-url)
                     (phrase-generate-callback ,(or token "\ufeff") ,format-fn ,ignore-read-only ,callback ,buffer-name))
       ;; For reference, \ufeff = Zero-width no-break space / BOM
       ,(or token "\ufeff"))))

(defun doom-dashboard-phrase ()
  (phrase-insert-async
   (progn
     (setq-local phrase-position (point))
     (mapconcat
      (lambda (line)
        (+doom-dashboard--center
         +doom-dashboard--width
         (with-temp-buffer
           (insert-text-button
            line
            'action
            (lambda (_)
              (setq phrase-last nil)
              (+doom-dashboard-reload t))
            'face 'doom-dashboard-menu-title
            'mouse-face 'doom-dashboard-menu-title
            'help-echo "Random phrase"
            'follow-link t)
           (buffer-string))))
      (split-string
       (with-temp-buffer
         (insert phrase)
         (setq fill-column (min 70 (/ (* 2 (window-width)) 3)))
         (fill-region (point-min) (point-max))
         (buffer-string))
       "\n")
      "\n"))
   nil t
   (progn
     (goto-char phrase-position)
     (forward-whitespace 1))
   +doom-dashboard-name))

(defadvice! doom-dashboard-widget-loaded-with-phrase ()
  :override #'doom-dashboard-widget-loaded
  (setq line-spacing 0.2)
  (insert
   "\n\n"
   (propertize
    (+doom-dashboard--center
     +doom-dashboard--width
     (doom-display-benchmark-h 'return))
    'face 'doom-dashboard-loaded)
   "\n"
   (doom-dashboard-phrase)
   "\n"))

(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(add-hook! '+doom-dashboard-mode-hook (hide-mode-line-mode 1) (hl-line-mode -1))
(setq-hook! '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+END_SRC
* Functionality
For the most part, DOOM Emacs handles 99% of the things I want to do in a text
editor and more, which is why this section is pretty brief.
Pretty much all of the functions I write end up under the "namespace"
=hzl/whatever=, on the merit that I want to avoid any clashes anywhere.
** MPDel music player
I usually use =ncmpcpp= for music, but sometimes when I'm working I use this.
It's all MPD, so it's not like they conflict.

We grab both MPDel and its Ivy interface:
#+BEGIN_SRC emacs-lisp :tangle ~/.config/doom/packages.el
(package! mpdel)
(package! ivy-mpdel)
#+END_SRC

We also disable evil in MPDel because its keybindings are contingent on doing
so.
#+BEGIN_SRC emacs-lisp
(use-package! mpdel
  :config
  (mpdel-mode)
  (set-evil-initial-state! '(mpdel-playlist-mode
                             mpdel-browser-mode
                             mpdel-song-mode
                             mpdel-tablist-mode)
    'emacs))
#+END_SRC

** Arbitrary Unicode input
While I like Agda's input mode for Unicode input, it's not practical everywhere,
and I occasionally need to put Unicode into non-Agda files (namely Racket when
writing DSLs using Unicode characters). DrRacket's approach is pretty good, so I
stole a package to emulate it.
#+BEGIN_SRC emacs-lisp :tangle ~/.config/doom/packages.el
(package! dr-racket-like-unicode
  :recipe (:host github :repo "david-christiansen/dr-racket-like-unicode"))
#+END_SRC

Bind it to C-\ everywhere, because I haven't found any situation where this
breaks anything:
#+BEGIN_SRC emacs-lisp
(use-package! dr-racket-like-unicode
  :config (map! :i "C-\\" #'dr-racket-like-unicode-char))
#+END_SRC
** LSP
Mostly handled by DOOM modules, but this causes Emacs to not fucking crash:
#+BEGIN_SRC emacs-lisp
(after! lsp-mode (setq lsp-enable-file-watchers nil))
#+END_SRC
* Productivity, papers, etc
For the boring stuff that's not /quite/ programming.
** TeXcount
This is a binding to a Perl script installed via =tlmgr= that... counts words.
Considering most of the papers I write have hard minimum/maximum limits, this
comes in pretty useful pretty often.
#+BEGIN_SRC emacs-lisp
(defun hzl/texcount ()
  ;; Counts words in a TeX file.
  (interactive)
  (let*
      ((this-file (buffer-file-name))
       (enc-str (symbol-name buffer-file-coding-system))
       (enc-opt
        (cond
         ((string-match "utf-8" enc-str) "-utf8")
         ((string-match "latin" enc-str) "-latin1")
         ("-encoding=guess")))
       (word-count
        (with-output-to-string
          (with-current-buffer standard-output
            (call-process "texcount" nil t nil "-0" enc-opt this-file)))))
    (message word-count)))
#+END_SRC

...and then, actually bind it to =C-c w= in LaTeX mode.
#+BEGIN_SRC emacs-lisp
(add-hook 'LaTeX-mode-hook (lambda () (define-key LaTeX-mode-map "\C-cw" 'hzl/texcount)))
#+END_SRC
** AucTeX =latexmk=
I use =latexmk= to build my LaTeX work because I use external files for my
bibliographies.
#+BEGIN_SRC emacs-lisp :tangle ~/.config/doom/packages.el
(package! auctex-latexmk)
#+END_SRC

We tell it to run the auto-setup function and use PDFs:
#+BEGIN_SRC emacs-lisp
(use-package! auctex-latexmk
  :config
  (auctex-latexmk-setup)
  (setq auctex-latexmk-inherit-TeX-pdf-mode t))
#+END_SRC
** Org-mode
Set the bullets to pretty stuff:
#+BEGIN_SRC emacs-lisp
(setq org-bullets-bullet-list '("☯" "☰" "☱" "☲" "☳" "☴" "☵" "☶" "☷"))
(setq org-ellipsis "↝")
#+END_SRC

Make sure that Org doesn't try to clutter my home directory, and put stuff where
it's supposed to be:
#+BEGIN_SRC emacs-lisp
(setq org-directory "~/usr/doc/org/")
#+END_SRC

Set DOOM's scratch buffer, available at any point with =SPC x=, to Org, which I
find useful for taking quick notes:
#+BEGIN_SRC emacs-lisp
(setq doom-scratch-buffer-major-mode 'org-mode)
#+END_SRC

We also grab =emacs-org=dnd=, for my character sheet:
#+BEGIN_SRC emacs-lisp :tangle ~/.config/doom/packages.el
(package! ox-dnd
  :recipe (:host github :repo "xeals/emacs-org-dnd"))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(use-package! ox-dnd)
#+END_SRC
** PDF Tools
While editing LaTeX documents, this is my PDF viewer of choice. Otherwise, I use
Zathura.
#+BEGIN_SRC emacs-lisp
(setq TeX-view-program-selection '((output-pdf "PDF Tools")))
(add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
#+END_SRC
* Programming languages
The cool stuff. Unless it's Java.
** Agda
The Doom module is kinda broken.

Grab the executable if we can find the =agda-mode= binary:
#+BEGIN_SRC emacs-lisp
(when (executable-find "agda-mode")
  (load-file
   (let ((coding-system-for-read 'utf-8))
     (shell-command-to-string "agda-mode locate"))))
#+END_SRC

Then copy straight from the Doom Agda module:
#+BEGIN_SRC emacs-lisp
(map! :after agda2-mode
      :map agda2-mode-map
      :localleader
      "?"   #'agda2-show-goals
      "."   #'agda2-goal-and-context-and-inferred
      ","   #'agda2-goal-and-context
      "="   #'agda2-show-constraints
      "SPC" #'agda2-give
      "a"   #'agda2-auto-maybe-all
      "b"   #'agda2-previous-goal
      "c"   #'agda2-make-case
      "d"   #'agda2-infer-type-maybe-toplevel
      "e"   #'agda2-show-context
      "f"   #'agda2-next-goal
      "gG"  #'agda2-go-back
      "h"   #'agda2-helper-function-type
      "l"   #'agda2-load
      "n"   #'agda2-compute-normalised-maybe-toplevel
      "p"   #'agda2-module-contents-maybe-toplevel
      "r"   #'agda2-refine
      "s"   #'agda2-solveAll
      "t"   #'agda2-goal-type
      "w"   #'agda2-why-in-scope-maybe-toplevel
      (:prefix "x"
        "c"   #'agda2-compile
        "d"   #'agda2-remove-annotations
        "h"   #'agda2-display-implicit-arguments
        "q"   #'agda2-quit
        "r"   #'agda2-restart))
#+END_SRC
** FRC Mode
This is a =gradlew= wrapper I hacked together really fast while sitting in my
physics class not paying attention. The officially sanctioned IDE for FIRST
Robotics is Visual Studio Code, which I hate with a burning passion for numerous
reasons.

Note that I'm no longer a FRC student, so if this ever goes out of date, sucks.
I'm planning on mentoring though, so it probably won't.

We grab it directly from my Git, since it's not in ELPA (and probably never will
be):
#+BEGIN_SRC emacs-lisp :tangle ~/.config/doom/packages.el
(package! frc-mode
  :recipe (:host nil :repo "https://git.knightsofthelambdacalcul.us/hazel/frc-mode" :branch "canon"))
#+END_SRC

And tell it to run with all Java files. I'd never willingly write Java outside
of FRC, so it's fine.
#+BEGIN_SRC emacs-lisp
(use-package! frc-mode
  :hook (java-mode . frc-mode))
#+END_SRC
** =rust-analyzer=
I have tons of issues with RLS -- it just does NOT behave. While I have to pull
=rust-analyzer= from unstable nixpkgs, and it's marked as unstable all over the
place, it's /still/ miles ahead of RLS.
#+BEGIN_SRC emacs-lisp
(after! rustic
  (setq rustic-lsp-server 'rust-analyzer))
#+END_SRC
** Scribble
The format for Racket documentation. Grab it from GitHub:
#+BEGIN_SRC emacs-lisp :tangle ~/.config/doom/packages.el
(package! scribble-mode
  :recipe (:host github :repo "emacs-pe/scribble-mode"))
#+END_SRC

Then enable it. It takes care of the file extensions itself.
#+BEGIN_SRC emacs-lisp
(use-package! scribble-mode)
#+END_SRC

** What
#+BEGIN_SRC emacs-lisp
(map! "C-;" nil)
#+END_SRC
